package edu.utexas.wrap;

import java.io.BufferedReader;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Collection;
import java.util.Collections;
import java.util.Map;
import java.util.Properties;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.Function;
import java.util.function.ToDoubleFunction;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import edu.utexas.wrap.assignment.Assigner;
import edu.utexas.wrap.assignment.BasicStaticAssigner;
import edu.utexas.wrap.assignment.bush.Bush;
import edu.utexas.wrap.assignment.bush.StreamPassthroughAssigner;
import edu.utexas.wrap.marketsegmentation.DummyPurpose;
import edu.utexas.wrap.marketsegmentation.Market;
import edu.utexas.wrap.net.AreaClass;
import edu.utexas.wrap.net.Link;
import edu.utexas.wrap.net.NetworkSkim;
import edu.utexas.wrap.net.TravelSurveyZone;
import edu.utexas.wrap.util.io.SkimFactory;
import edu.utexas.wrap.util.io.output.FilePassthroughDummyAssigner;

/** A high-level representation of a multi-market, multi-purpose travel demand model. This class 
 * defines the set of TravelSurveyZones for which demand should be modeled, as well as the Market
 * instances which travel among these zones. Instances of this class may also define a number of
 * Assigner instances which consume ODProfiles generated by the Markets' Purposes, as well as an
 * initial set of NetworkSkims which may be relevant in ODProfile creation. These skims should be
 * updated by the Assigners after their termination.
 * 
 * The Project should define a project directory. This directory should contain all data relevant
 * to the Project, as it will serve as the point against which all relative paths will be resolved.
 * 
 * @author William
 *
 */
public class Project {
	private final Properties props;
//	private Graph network;
	private Map<Integer, TravelSurveyZone> zones;
	private Path projDir;
	private String name;
	
	/**Constructor with custom id for Project
	 * 
	 * @param projFile The location of a Project Properties file (*.wrp)
	 * @param id a custom name of this project
	 * @throws IOException if the file located by {@code projFile} does not exist or is corrupt 
	 */
	public Project(Path projFile, String id) throws IOException {
		props = new Properties();
		props.load(Files.newInputStream(projFile));
		this.name = id;
		
		projDir = projFile.getParent().resolve(props.getProperty("dir"));
		zones = getZones();
//		network = readNetwork();
//		throw new RuntimeException("Zones not loaded");
	}
	
	/**Project constructor from a Properties file (*.wrp)
	 * @param projFile the location of a Project Properties (*.wrp) file
	 * @throws IOException if the file located by {@code projFile} does not exist or is corrupt
	 */
	public Project(Path projFile) throws IOException {
		this(projFile, projFile.getFileName().toString());
	}
	
	private Map<Integer, TravelSurveyZone> getZones() throws IOException {
		BufferedReader reader = Files.newBufferedReader(projDir.resolve(props.getProperty("network.zones")));
		reader.readLine();
		AtomicInteger idx = new AtomicInteger(0);

		Map<Integer, TravelSurveyZone> zones = reader.lines()
				.map(string -> string.split(","))
				.collect(Collectors.toMap(
						args -> Integer.parseInt(args[0]), 
						args -> new TravelSurveyZone(Integer.parseInt(args[0]),idx.getAndIncrement(),AreaClass.values()[Integer.parseInt(args[1])-1])));
		return zones;
	}

	/**Read a list of Market ids from the Project Properties, then load the
	 * corresponding Markets from the corresponding file. 
	 * 
	 * The list of Markets is
	 * defined with the Property key {@code markets.ids}; for each id {@code foo} in
	 * this list, a corresponding key {@code markets.foo.file} must be defined. The 
	 * {@code .file} should be a relative path from the Project directory to a file
	 * (*.wrm) containing the Market Properties associated with this id. 
	 * 
	 * @return a Collection of initialized Markets read from files
	 */
	public Collection<Market> loadMarkets(){
		System.out.println("Reading Market configurations");

		String projNames = props.getProperty("markets.ids");
		
		if (projNames == null) 
			throw new RuntimeException("No markets specified in project properties. Define at least one market");
		
		else return 
				Stream.of(projNames.split(","))
				.map(name -> {
					try {
						return new Market(projDir.resolve(props.getProperty("markets."+name+".file")), zones);
					} catch (IOException e) {
						System.err.println("Could not load trip purposes for "+name);
						e.printStackTrace();
						return null;
					}
				})
				.collect(Collectors.toSet());
	}
	
	/**
	 * @return
	 */
	public Collection<DummyPurpose> getDummyPurposes() {
		// TODO Auto-generated method stub
		String dummyNames = props.getProperty("dummies.ids");
		
		if (dummyNames == null) return Collections.emptySet();
		else return Stream.of(dummyNames.split(","))
				.map(name ->{
					try {
						return new DummyPurpose(projDir.resolve(props.getProperty("dummies."+name+".file")), zones);
					} catch (IOException e) {
						System.out.println("Could not load dummy trip purpose "+name);
						e.printStackTrace();
						return null;
					}
				})
				.collect(Collectors.toSet());
	}
	
	/**Read a list of Assigner ids from the Project Properties, then load the
	 * corresponding Assigners according to their definition. 
	 * 
	 * The list of Assigners is
	 * defined with the Property key {@code assigners.ids}; for each id {@code foo} in
	 * the list, a corresponding key {@code assigners.foo.class} must be defined. The
	 * @{code .class} should be an available Assigner implementation. Depending on the
	 * Assigner class specified, an additional key {@code assigners.foo.file} may 
	 * define a relative path from the Project directory to a file (*.wrapr) containing
	 * the Assigner Properties associated with this id.
	 * 
	 * @return a Map from an Assigner's id to newly-generated instance.
	 */
	public Map<String,Assigner> loadAssigners(){
		System.out.println("Reading Assigner configurations");

		return Stream.of(props.getProperty("assigners.ids").split(","))
		.collect(Collectors.toMap(Function.identity(), id -> initializeAssigner(id)));
	}
	
	/**Read a list of NetworkSkim ids from the Project Properties, then load the
	 * corresponding NetworkSkims from the corresponding file. 
	 * 
	 * The list of NetworkSkims is defined with the Property key {@code skims.ids}; 
	 * for each id {@code foo} in the list, a corresponding key {@code skims.foo.file} 
	 * must be defined. The {@code .file} should be a relative path from the Project 
	 * directory to a file (*.csv) containing the data associated with the initial cost
	 * skims to be used in building the Project's ODProfiles
	 *  
	 * the ODProfiles of the project.
	 * 
	 * @return a Map from a NetworkSkim's id to its newly-generated instance
	 */
	public Map<String,NetworkSkim> loadInitialSkims(){
		System.out.println("Reading initial NetworkSkims");
		
		return Stream.of(props.getProperty("skims.ids").split(","))
				.parallel()
				.collect(
						Collectors.toMap(
								Function.identity(), 
								id -> SkimFactory.readSkimFile(
										projDir.resolve(props.getProperty("skims."+id+".file")), 
										false, 
										zones
										)
								)
						)
		;
	}
	
	/**Read a list of NetworkSkim ids from the Project Properties, then get the updated
	 * NetworkSkims from their associated Assigners. 
	 * 
	 * The list of NetworkSkims is defined with the Property key {@code skims.ids};
	 * for each id {@code foo} in the list, a corresponding key {@code skims.foo.assigner}
	 * must be defined. The {@code .assigner} should be an Assigner id defined in the
	 * {@code assigners.ids} property. Additionally, the key {@code skims.foo.function}
	 * specifies the cost function to be used by the Assigner in calculating the updated 
	 * cost skim.
	 * 
	 * @param assigners a Map from Assigner ids to their current instance
	 * @return a Map from NetworkSkim ids to their updated instance
	 */
	public Map<String,NetworkSkim> updateFeedbackSkims(Map<String,Assigner> assigners){
		System.out.println("Updating NetworkSkims");

		return Stream.of(props.getProperty("skims.ids").split(","))
		.parallel()
		.collect(
				Collectors.toMap(
						Function.identity(),
						id ->{
							Assigner assigner = assigners.get(props.getProperty("skims."+id+".assigner"));
							ToDoubleFunction<Link> func;
							switch (props.getProperty("skims."+id+".function")) {
							default:
								System.err.println("Skim funciton not yet implemented. Reverting to travel time");
							case "travelTime":
								func = Link::getTravelTime;
							}
							return assigner.getSkim(func);
						}
						)
				);

	}

	private Assigner initializeAssigner(String id) {
		try {

			switch (props.getProperty("assigners."+id+".class")) {
			case "stream":
				return new StreamPassthroughAssigner(
						projDir.resolve(props.getProperty("assigners."+id+".file"))
						);


			case "bush":
				return new BasicStaticAssigner<Bush>(
						projDir.resolve(props.getProperty("assigners."+id+".file")),
						zones
						);
			case "file":
				return new FilePassthroughDummyAssigner(projDir.resolve(props.getProperty("assigners."+id+".file")),zones);
			default:
				throw new RuntimeException("Not yet implemented");
			}
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			return null;
		}
	}

	
	/**
	 * @param assigners
	 */
	public void output(Map<String,Assigner> assigners) {
		// TODO Auto-generated method stub
		Map<String,NetworkSkim> finalSkims = updateFeedbackSkims(assigners);
		System.out.println("Printing final skims");
		finalSkims.entrySet().stream()
		.filter(entry -> Boolean.parseBoolean(props.getProperty("skims."+entry.getKey()+".overwrite")))
		.forEach(
				entry -> SkimFactory.outputCSV(
						finalSkims.get(entry.getKey()),
						projDir.resolve(props.getProperty("skims."+entry.getKey()+".file")),
						zones.values()
						)
				);
		
		
		System.out.println("Printing final flows");
		assigners.forEach((id, assigner) -> {
			assigner.outputFlows(projDir.resolve(id+"flows.csv"));
		});

	}
	
	/**
	 *
	 */
	public String toString() {
		return name;
	}



}