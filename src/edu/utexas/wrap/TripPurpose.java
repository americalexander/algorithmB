package edu.utexas.wrap;

import java.util.Collection;
import java.util.Map;
import java.util.Map.Entry;
import java.util.stream.Stream;

import edu.utexas.wrap.demand.AggregatePAMatrix;
import edu.utexas.wrap.demand.DemandMap;
import edu.utexas.wrap.demand.ModalPAMatrix;
import edu.utexas.wrap.demand.ODMatrix;
import edu.utexas.wrap.demand.PAMap;
import edu.utexas.wrap.marketsegmentation.MarketSegment;

public interface TripPurpose {

	/**
	 * @return a Stream of key-value pairs where the key is a MarketSegment and
	 * its value is a DemandMap representing the productions at each zone for
	 * trips generated by this MarketSegment
	 */
	public Stream<Entry<MarketSegment, DemandMap>> getProductions();
	
	/**
	 * @return a Stream of key-value pairs where the key is a MarketSegment and
	 * its value is a DemandMap representing the attractions at each zone for
	 * trips genreated by this MarketSegment
	 */
	public Stream<Entry<MarketSegment, DemandMap>> getAttractions();
	
	/**This method combines production and attraction DemandMaps according to
	 * some rule set for matching productions and attractions
	 * 
	 * @param prods a Stream of MarketSegment-DemandMap pairs for productions
	 * @param attrs a Stream of MarketSegment-DemandMap pairs for attractions
	 * @return a Stream of MarketSegment-PAMap pairs that combine the inputs
	 * according to some rule set
	 */
	public Stream<Entry<MarketSegment, PAMap>> buildProductionAttractionMaps(
			Stream<Entry<MarketSegment, DemandMap>> prods,
			Stream<Entry<MarketSegment, DemandMap>> attrs);
	
	/**This method balances PAMaps according to some rule set, thus ensuring
	 * that for each input entry, the corresponding output entry has the
	 * same number of productions as attractions
	 * 
	 * @param paMaps a Stream of MarketSegment-PAMap pairs that may or may not be unbalanced 
	 * @return a corresponding Stream of MarketSegment-PAMap pairs where each PAMap is
	 * guaranteed to have the same number of productions as attractions
	 */
	public Stream<Entry<MarketSegment, PAMap>> balance(
			Stream<Entry<MarketSegment,PAMap>> paMaps);
	
	/**This method converts PAMaps to PAMatrices by distributing trips, i.e. linking
	 * the productions to the attractions in two-dimensional form. That is to say,
	 * for each production zone, its productions are divided across the attraction
	 * zones according to some mechanism
	 * 
	 * @param paMaps a Stream of MarketSegment-PAMap pairs to be distributed
	 * @return the corresponding Stream of MarketSegment-AggregatePAMatrix pairs
	 */
	public Stream<Entry<MarketSegment, AggregatePAMatrix>> distribute(
			Stream<Entry<MarketSegment,PAMap>> paMaps);
	
	/**This method performs mode choice on an AggregatePAMatrix by dividing
	 * its trips across multiple modes and returning a collection of those
	 * ModalPAMatrices paired to each MarketSegment
	 * 
	 * @param paMatrices a Stream of MarketSegment-AggregatePAMatrix pairs that
	 * should undergo mode choice and be divided into multiple ModalPAMatrices
	 * @return the corresponding output Stream of pairs linking a MarketSegment
	 * to its Collection of ModalPAMatrices
	 */
	public Stream<Entry<MarketSegment, Collection<ModalPAMatrix>>> modeChoice(
			Stream<Entry<MarketSegment,AggregatePAMatrix>> paMatrices);
	
	/**This method converts ModalPAMatrices to ODMatrices and divides trips
	 * across different TimePeriods, according to some rule set
	 * 
	 * @param paMatrices a Stream of MarketSegments and their corresponding
	 * Collection of ModalPAMatrices
	 * @return a Stream where, for each input pair, the MarketSegment is output
	 * with a paired mapping from TimePeriods to their Collection of ODMatrices,
	 * according to some rule set for dividing across TimePeriods and converting
	 * ModalPAMatrices to ODMatrices
	 */
	public Stream<Entry<MarketSegment, Map<TimePeriod, Collection<ODMatrix>>>> convertToOD(
			Stream<Entry<MarketSegment,Collection<ModalPAMatrix>>> paMatrices);

	/**This method provides access to the completed ODMatrix structure for each MarketSegment
	 * @return for each MarketSegment, the pair linking it to a Map from TimePeriods to
	 * a Collection of ODMatrices which should be loaded during that TimePeriod's assignment
	 */
	public Stream<Entry<MarketSegment,Map<TimePeriod,Collection<ODMatrix>>>> getODMaps();
	
	/**
	 * @return a String representation of this TripPurpose
	 */
	public String toString();	
}
