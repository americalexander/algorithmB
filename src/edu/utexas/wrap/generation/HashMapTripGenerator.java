package edu.utexas.wrap.generation;

import java.util.Map;

import edu.utexas.wrap.demand.MarketSegment;
import edu.utexas.wrap.demand.containers.AggregatePAHashMap;
import edu.utexas.wrap.net.Graph;

/**A primary trip generator that uses TSZs' attributes to
 * calculate the number of generated trips. For each market
 * segment, a rate is given for each TSZ attribute. The rate
 * is then multiplied by the attribute value for the TSZ to
 * calculate the number of trips generated by the TSZ in that
 * market segment as determined by that attribute. These are
 * aggregated into the MarketSegment's AggregatePAMap
 * 
 * @author William
 *
 */
public class HashMapTripGenerator extends PrimaryTripGenerator {

	private Map<MarketSegment, Map<String, Float>> prodRates;
	private Map<MarketSegment, Map<String, Float>> attrRates; 
	private Graph graph;

	public HashMapTripGenerator(Graph g, Map<MarketSegment, Map<String, Float>> prodRates, Map<MarketSegment,Map<String,Float>> attrRates) {
		graph = g;
		this.prodRates = prodRates;
		this.attrRates = attrRates;
	}

	@Override
	public AggregatePAHashMap generate(MarketSegment segment) {
		Map<String,Float> segmentProdRates = prodRates.get(segment);
		Map<String,Float> segmentAttrRates = attrRates.get(segment);
		AggregatePAHashMap aggregate = new AggregatePAHashMap(graph);


		graph.getTSZs().parallelStream().forEach(z ->{

			float prods = (float) segmentProdRates.entrySet().parallelStream().mapToDouble(x -> x.getValue()*z.valueOf(x.getKey())).sum();
			float attrs = (float) segmentAttrRates.entrySet().parallelStream().mapToDouble(x -> x.getValue()*z.valueOf(x.getKey())).sum();

			aggregate.putProductions(z, prods);
			aggregate.putAttractions(z, attrs);
		});
		return aggregate;
	}

}
